<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>War Zone Tactical Shooter â€“ Playable Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a; /* Darker background for drama */
            font-family: 'Inter', sans-serif; /* Using Inter font */
            color: #fff;
            display: block; /* Changed to block */
            align-items: center; /* No longer needed with block display */
            justify-content: flex-start; /* No longer needed with block display */
            height: 100vh; /* Ensure body takes full viewport height */
            width: 100vw; /* Ensure body takes full viewport width */
            position: relative; /* Needed for absolute children */
        }
        canvas {
            display: block;
            width: 100vw; /* Make canvas fill viewport width */
            height: 100vh; /* Make canvas fill viewport height */
            position: absolute; /* Position absolutely to cover the whole viewport */
            top: 0;
            left: 0;
            z-index: 1; /* Place below UI */
        }
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px; /* Height for UI elements */
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between; /* Changed to space-between for pause button */
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
            font-size: 1.2rem;
            z-index: 50; /* Place above canvas */
            border-bottom-left-radius: 10px;
            border-bottom-right-radius: 10px;
        }
        #healthBar {
            width: 200px;
            height: 20px;
            background: #555;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #fff;
        }
        #healthFill {
            height: 100%;
            width: 100%; /* Will be updated by JS */
            background: linear-gradient(to right, #00ff00, #ff0000);
            transition: width 0.2s ease-out;
            border-radius: 5px;
        }
        #dramaOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* Allow multiple lines for messages */
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 2.5rem;
            text-align: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
            border-radius: 10px; /* Rounded corners */
        }
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.4);
            opacity: 0;
            pointer-events: none;
            z-index: 40;
            transition: opacity 0.1s ease-out;
            border-radius: 10px; /* Rounded corners */
        }
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column; /* Allow stacking of text and bar */
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 2rem;
            z-index: 101;
        }

        #loadingBarContainer {
            width: 80%;
            max-width: 400px; /* Limit max width for better appearance */
            background: #333;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px;
            border: 1px solid #00ffff; /* Cyan border */
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5); /* Cyan glow */
        }

        #loadingBarFill {
            width: 0%;
            background: linear-gradient(to right, #00ffff, #007bff); /* Cyan to blue gradient */
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease-out; /* Smooth transition for fill */
        }

        /* Mobile Controls Styling */
        #mobileControls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 10px;
            box-sizing: border-box;
            z-index: 60; /* Place above canvas */
        }

        #dPad {
            display: grid;
            grid-template-columns: repeat(3, 60px); /* Increased size */
            grid-template-rows: repeat(3, 60px);    /* Increased size */
            gap: 8px; /* Increased gap */
            background: rgba(50, 50, 50, 0.7);
            border-radius: 20px; /* More rounded */
            padding: 15px; /* Increased padding */
        }

        .dPadButton {
            width: 60px; /* Increased size */
            height: 60px; /* Increased size */
            background: #333;
            border: 2px solid #555;
            border-radius: 12px; /* More rounded */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem; /* Larger font */
            color: #eee;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            touch-action: manipulation;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Added shadow */
            transition: background 0.1s ease, box-shadow 0.1s ease;
        }
        .dPadButton:active {
            background: #555;
            border-color: #777;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); /* Pressed state shadow */
        }

        #upButton { grid-area: 1 / 2 / 2 / 3; }
        #leftButton { grid-area: 2 / 1 / 3 / 2; }
        #downButton { grid-area: 3 / 2 / 4 / 3; }
        #rightButton { grid-area: 2 / 3 / 3 / 4; }
        /* Center button is empty */

        #actionButtons {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Increased gap */
        }

        .actionButton {
            width: 90px; /* Increased size */
            height: 90px; /* Increased size */
            background: #007bff;
            border: 2px solid #0056b3;
            border-radius: 50%; /* Circular buttons */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem; /* Larger font */
            font-weight: bold;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            touch-action: manipulation;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background 0.1s ease, box-shadow 0.1s ease;
        }
        .actionButton:active {
            background: #0056b3;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        #specialAttackButton {
            background: #dc3545; /* Red for special attack */
            border-color: #b02a37;
            position: relative; /* For cooldown overlay */
        }
        #specialAttackButton:active {
            background: #b02a37;
        }

        /* Special Attack Cooldown Overlay */
        #specialAttackCooldownOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7); /* Dark overlay */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: white;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 1; /* Above button content */
        }
        #specialAttackCooldownOverlay.visible {
            opacity: 1;
        }


        /* Pause Button Styling */
        #pauseButton {
            background: #6c757d; /* Grey for pause */
            border: 2px solid #5a6268;
            border-radius: 8px;
            color: white;
            padding: 8px 15px;
            font-size: 1rem;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            touch-action: manipulation;
            transition: background 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #pauseButton:active {
            background: #5a6268;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* Home Screen Styling */
        #homeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0d0d0d; /* Very dark background */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 102; /* Above loading screen */
            color: #fff;
            text-align: center;
        }

        #homeScreen h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #00ffff; /* Cyan title */
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }

        #startButton {
            padding: 15px 40px;
            font-size: 1.8rem;
            background: linear-gradient(45deg, #007bff, #00c6ff);
            border: none;
            border-radius: 15px;
            color: white;
            cursor: pointer;
            box-shadow: 0 8px 15px rgba(0, 123, 255, 0.4);
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            /* Disable button initially */
            opacity: 0.5;
            cursor: not-allowed;
        }

        #startButton:not([disabled]):hover {
            background: linear-gradient(45deg, #0056b3, #0099cc);
            box-shadow: 0 12px 20px rgba(0, 123, 255, 0.6);
            transform: translateY(-3px);
        }

        #startButton:not([disabled]):active {
            transform: translateY(1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Volume Control Styling */
        #volumeControl {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 20px; /* Space from pause button */
        }

        #volumeControl label {
            font-size: 1rem;
        }

        #volumeSlider {
            width: 100px;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #555;
            outline: none;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        #volumeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        #volumeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Landscape Mode Enforcement for Mobile */
        @media screen and (orientation: portrait) and (max-width: 768px) {
            #portraitMessage {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                color: #fff;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-size: 1.8rem;
                text-align: center;
                z-index: 103; /* Above all other elements */
            }
            #portraitMessage p {
                margin: 20px;
            }
            #mobileControls, #gameUI, canvas {
                display: none; /* Hide game elements in portrait */
            }
        }

        @media screen and (orientation: landscape) and (max-width: 768px) {
            #portraitMessage {
                display: none; /* Hide message in landscape */
            }
            #mobileControls, #gameUI, canvas {
                display: flex; /* Show game elements in landscape */
            }
        }

        /* Mini-map styling */
        #miniMapContainer {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 150px; /* Smaller mini-map */
            height: 150px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff; /* Cyan border for mini-map */
            border-radius: 10px;
            overflow: hidden;
            z-index: 55; /* Above canvas, below mobile controls */
            display: none; /* Hidden by default */
        }
        #miniMapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        Loading Game...
        <div id="loadingBarContainer">
            <div id="loadingBarFill"></div>
        </div>
    </div>

    <!-- Home Screen -->
    <div id="homeScreen">
        <h1>WAR ZONE TACTICAL SHOOTER</h1>
        <button id="startButton" disabled>Start Game</button>
    </div>

    <!-- Portrait Message for Mobile -->
    <div id="portraitMessage" style="display: none;">
        <p>Please rotate your device to landscape mode for the best experience!</p>
        <p>ðŸŽ®</p>
    </div>

    <div id="gameUI" style="display: none;">
        <button id="pauseButton">Pause</button> <!-- Pause Button -->
        <div id="volumeControl">
            <label for="volumeSlider">Volume:</label>
            <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="0.5">
        </div>
        <div>Health: <div id="healthBar"><div id="healthFill"></div></div></div>
        <div id="scoreDisplay">Score: 0</div>
    </div>
    <div id="dramaOverlay"></div>
    <div id="damageFlash"></div>

    <!-- Mini-map Container -->
    <div id="miniMapContainer">
        <canvas id="miniMapCanvas"></canvas>
    </div>

    <!-- Mobile Controls -->
    <div id="mobileControls" style="display: none;">
        <div id="dPad">
            <div class="dPadButton" id="upButton" data-key="KeyW">â–²</div>
            <div class="dPadButton" id="leftButton" data-key="KeyA">â—€</div>
            <div class="dPadButton" id="downButton" data-key="KeyS">â–¼</div>
            <div class="dPadButton" id="rightButton" data-key="KeyD">â–¶</div>
        </div>
        <div id="actionButtons">
            <div class="actionButton" id="shootButton" data-key="Space">Shoot</div>
            <div class="actionButton" id="specialAttackButton" data-key="KeyQ">
                Special
                <div id="specialAttackCooldownOverlay"></div>
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Tone.js Library for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        // --- Global Constants ---
        const WORLD_BOUNDARY = 100;
        const WORLD_MIN = -100;
        const WORLD_SIZE = WORLD_BOUNDARY - WORLD_MIN; // Total width/depth of the game world (200)
        const PLAYER_BASE_SPEED = 15;
        const BULLET_SPEED = 100;
        const PLAYER_BASE_BULLET_DAMAGE = 30;
        const ENEMY_BULLET_DAMAGE = 8; // Reduced enemy bullet damage
        const PLAYER_COLOR = 0x0000ff;
        const ENEMY_COLOR = 0xff0000;
        const OBSTACLE_COLOR = 0x444444;
        const FRIENDLY_ZONE_COLOR = 0x00ff00; // Green for friendly
        const ENEMY_ZONE_COLOR = 0x0000ff; // Blue for multi-target
        const HAZARD_ZONE_COLOR = 0xff0000; // Red for hazard
        const ENEMY_SHOOT_INTERVAL = 1.5; // seconds
        const HAZARD_DAMAGE_RATE = 5; // Damage per second in hazard zone
        const SPECIAL_ATTACK_COOLDOWN = 10; // seconds
        const MAX_BULLETS_IN_POOL = 50; // Max bullets to keep in the pool
        const PARTICLE_COUNT = 2000; // Number of background particles
        const PARTICLE_SPEED = 0.5; // Speed of background particles
        const HEALTH_PACK_RESPAWN_TIME = 15; // seconds
        const HEALTH_RECOVERY_RATE = 20; // Increased Health per second in green zone
        const MULTI_TARGET_DURATION = 8; // Increased seconds for blue zone effect
        const MULTI_TARGET_COUNT = 3; // Number of enemies to target in blue zone
        const POWERUP_PICKUP_RADIUS = 5; // Increased radius for picking up power-ups
        const DAMAGE_SPEED_BOOST_DURATION = 7; // Duration for damage and speed boosts
        const ENEMY_AVOIDANCE_RADIUS = 10; // Radius for enemy to start avoiding obstacles
        const ENEMY_AVOIDANCE_FORCE = 0.5; // Strength of avoidance force

        // --- Three.js Scene Setup ---
        let scene, camera, renderer, clock;
        let dramaOverlay, damageFlash, healthFill, scoreDisplay, pauseButton, volumeSlider;
        let homeScreen, startButton, portraitMessage;
        let loadingScreen, loadingBarFill; // New loading bar elements
        let specialAttackCooldownOverlay; // New element for special attack cooldown
        let miniMapContainer, miniMapCanvas, miniMapCtx; // Mini-map elements
        let cameraShakeIntensity = 0;
        let cameraShakeTime = 0;
        let isGameActive = false;
        let isGamePaused = false; // New state variable for pause

        // --- Game State Variables ---
        let playerMesh, playerShieldMesh;
        let enemies = [];
        let obstacles = [];
        let powerUps = [];
        let playerBullets = [];
        let enemyBullets = [];
        let explosionParticles = [];
        let damageNumbers = [];
        let hazardZoneMesh = null;
        let hazardZoneCenter = new THREE.Vector3();
        let hazardZoneRadius = 15;
        let backgroundParticles; // Reference to the background particle system

        let greenZoneMesh = null; // Reference to the green zone mesh
        let blueZoneMesh = null; // Reference to the blue zone mesh
        let isMultiTargetActive = false; // State for blue zone effect
        let multiTargetEndTime = 0; // End time for blue zone effect

        let playerHealth = 100;
        let playerScore = 0;
        let playerInvincible = false;
        let keys = {};
        let lastPlayerShotTime = 0;
        const playerShootCooldown = 0.2;

        let enemySpawnTimer = 0;
        // Reduced to 25 seconds for fewer enemies
        const enemySpawnInterval = 25; 

        let scoreMultiplierActive = false;
        let scoreMultiplierEndTime = 0;
        const SCORE_MULTIPLIER_DURATION = 10; // seconds

        let playerDamageMultiplier = 1;
        let playerSpeedMultiplier = 1;
        let damageMultiplierEndTime = 0;
        let speedMultiplierEndTime = 0;
        let lastSpecialAttackTime = -SPECIAL_ATTACK_COOLDOWN; // Allows immediate use at start
        let specialAttackReady = false;

        // --- Wave System Variables ---
        let currentWave = 0;
        let enemiesInCurrentWave = 0;
        let enemiesRemainingInWave = 0;
        // Reduced number of enemies per wave significantly
        const WAVE_CONFIG = [
            { numEnemies: 3, bossChance: 0.1, powerUpChance: 0.5 },
            { numEnemies: 5, bossChance: 0.2, powerUpChance: 0.6 },
            { numEnemies: 7, bossChance: 0.3, powerUpChance: 0.7 },
            { numEnemies: 10, bossChance: 0.4, powerUpChance: 0.8 },
            { numEnemies: 12, bossChance: 0.5, powerUpChance: 0.9 }
            // Removed finalWave: true to allow indefinite play
        ];

        // --- Audio Elements (using Tone.js) ---
        let shootSound, explosionSound, powerupSound, specialAttackSound, bgMusicSynth, bgMusicLoop;

        // --- Object Pools ---
        const bulletPool = []; // Pool for player and enemy bullets

        // --- Asset Loading & Preloading (now handles Tone.js setup) ---
        function preloadAssets() {
            console.log("Preloading assets...");
            loadingScreen = document.getElementById('loadingScreen');
            loadingBarFill = document.getElementById('loadingBarFill');
            
            loadingScreen.style.display = 'flex';
            loadingBarFill.style.width = '0%'; // Reset loading bar

            // Get references to homeScreen and portraitMessage early
            homeScreen = document.getElementById('homeScreen');
            portraitMessage = document.getElementById('portraitMessage');
            startButton = document.getElementById('startButton'); 
            specialAttackCooldownOverlay = document.getElementById('specialAttackCooldownOverlay'); // Get overlay element

            // Simulate asset loading progress
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += 10;
                loadingBarFill.style.width = progress + '%';
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                    console.log("Assets loaded.");
                    init(); // Call init after simulated loading is complete

                    // Add 1-second delay before enabling start button
                    setTimeout(() => {
                        startButton.disabled = false;
                        startButton.style.opacity = 1;
                        startButton.style.cursor = 'pointer';
                        loadingScreen.style.display = 'none'; // Hide loading screen
                        checkOrientation(); // Check orientation to show home screen or portrait message
                    }, 1000); // 1-second delay
                }
            }, 100); // Update every 100ms
        }

        // --- Initialization ---
        function init() {
            console.log("Game initialized (visuals only).");
            dramaOverlay = document.getElementById('dramaOverlay');
            damageFlash = document.getElementById('damageFlash');
            healthFill = document.getElementById('healthFill');
            scoreDisplay = document.getElementById('scoreDisplay');
            pauseButton = document.getElementById('pauseButton'); 
            volumeSlider = document.getElementById('volumeSlider'); 
            
            // Mini-map setup
            miniMapContainer = document.getElementById('miniMapContainer');
            miniMapCanvas = document.getElementById('miniMapCanvas');
            miniMapCtx = miniMapCanvas.getContext('2d');
            miniMapCanvas.width = miniMapContainer.offsetWidth;
            miniMapCanvas.height = miniMapContainer.offsetHeight;


            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x333333, 0.002); // Reduced fog density

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 80); // Adjusted camera position
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); // Adjusted to full window size
            document.body.appendChild(renderer.domElement);
            renderer.domElement.style.display = 'none'; // Hide canvas initially

            // Clock for delta time
            clock = new THREE.Clock();

            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // Reduced AmbientLight intensity
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            // Ground
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshPhongMaterial({ color: 0x222222 })
            );
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Create boundaries (includes fixed hazard zone)
            drawBoundaries();

            // Player Model - More creative tank-like model
            const playerBodyGeometry = new THREE.BoxGeometry(3, 1.5, 4); // Main body (wider, lower)
            const playerBodyMaterial = new THREE.MeshPhongMaterial({ color: PLAYER_COLOR, shininess: 80 });
            const playerBody = new THREE.Mesh(playerBodyGeometry, playerBodyMaterial);
            playerBody.position.y = 0.75; // Half of height to sit on ground

            // Side armor plates
            const armorPlateGeometry = new THREE.BoxGeometry(0.5, 1.2, 3.5);
            const armorPlateMaterial = new THREE.MeshPhongMaterial({ color: 0x0044bb, shininess: 60 }); // Darker blue
            const leftArmor = new THREE.Mesh(armorPlateGeometry, armorPlateMaterial);
            leftArmor.position.set(-1.8, 0.75, 0);
            playerBody.add(leftArmor);
            const rightArmor = new THREE.Mesh(armorPlateGeometry, armorPlateMaterial);
            rightArmor.position.set(1.8, 0.75, 0);
            playerBody.add(rightArmor);

            // Tracks
            const trackGeometry = new THREE.BoxGeometry(0.5, 1.5, 4.2); // Thin, long boxes for tracks
            const trackMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 30 });
            const leftTrack = new THREE.Mesh(trackGeometry, trackMaterial);
            leftTrack.position.set(-1.75, 0.75, 0); // Position left of body
            const rightTrack = new THREE.Mesh(trackGeometry, trackMaterial);
            rightTrack.position.set(1.75, 0.75, 0); // Position right of body
            playerBody.add(leftTrack);
            playerBody.add(rightTrack);

            // Turret Base
            const playerTurretBaseGeometry = new THREE.CylinderGeometry(0.8, 1.2, 0.8, 8); // Wider, shorter base
            const playerTurretBaseMaterial = new THREE.MeshPhongMaterial({ color: 0x0088ff, shininess: 80 });
            const playerTurretBase = new THREE.Mesh(playerTurretBaseGeometry, playerTurretBaseMaterial);
            playerTurretBase.position.y = 1.5;

            // Turret Top
            const playerTurretTopGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.7, 8); // Narrower, taller top
            const playerTurretTopMaterial = new THREE.MeshPhongMaterial({ color: 0x0088ff, shininess: 80 });
            const playerTurretTop = new THREE.Mesh(playerTurretTopGeometry, playerTurretTopMaterial);
            playerTurretTop.position.y = 0.75; // On top of the base
            playerTurretBase.add(playerTurretTop);

            const playerBarrelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 3, 8); // Barrel
            const playerBarrelMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, shininess: 50 });
            const playerBarrel = new THREE.Mesh(playerBarrelGeometry, playerBarrelMaterial);
            playerBarrel.rotation.x = Math.PI / 2; // Point barrel forward
            playerBarrel.position.set(0, 0, -1.5); // Position in front of turret top
            playerTurretTop.add(playerBarrel); // Barrel is part of the turret top

            playerMesh = new THREE.Group();
            playerMesh.add(playerBody);
            playerMesh.add(playerTurretBase); // Turret base is added directly to playerMesh
            playerMesh.position.set(0, 0, 0); // Group position
            scene.add(playerMesh);

            // Store references to player's main body and turret materials for easy manipulation
            playerMesh.userData.bodyMaterial = playerBodyMaterial;
            playerMesh.userData.turretMaterial = playerTurretTopMaterial; // Use turret top for glow

            // Shield visual for player (attach to the group) - Changed to MeshPhongMaterial
            const shieldGeometry = new THREE.SphereGeometry(3, 16, 16); // Slightly larger for the group
            const shieldMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                opacity: 0.3, 
                transparent: true, 
                blending: THREE.AdditiveBlending,
                emissive: 0x00ffff, // Added emissive property
                emissiveIntensity: 1.0 // Added emissive intensity
            });
            playerShieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            playerMesh.add(playerShieldMesh);

            // Create particle background
            createParticleBackground();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('keyup', onKeyUp, false);

            // Mobile Controls Event Listeners
            document.getElementById('upButton').addEventListener('touchstart', (e) => { e.preventDefault(); keys['KeyW'] = true; }, { passive: false });
            document.getElementById('upButton').addEventListener('touchend', (e) => { e.preventDefault(); keys['KeyW'] = false; });
            document.getElementById('leftButton').addEventListener('touchstart', (e) => { e.preventDefault(); keys['KeyA'] = true; }, { passive: false });
            document.getElementById('leftButton').addEventListener('touchend', (e) => { e.preventDefault(); keys['KeyA'] = false; });
            document.getElementById('downButton').addEventListener('touchstart', (e) => { e.preventDefault(); keys['KeyS'] = true; }, { passive: false });
            document.getElementById('downButton').addEventListener('touchend', (e) => { e.preventDefault(); keys['KeyS'] = false; });
            document.getElementById('rightButton').addEventListener('touchstart', (e) => { e.preventDefault(); keys['KeyD'] = true; }, { passive: false });
            document.getElementById('rightButton').addEventListener('touchend', (e) => { e.preventDefault(); keys['KeyD'] = false; });

            document.getElementById('shootButton').addEventListener('touchstart', (e) => { e.preventDefault(); keys['Space'] = true; }, { passive: false });
            document.getElementById('shootButton').addEventListener('touchend', (e) => { e.preventDefault(); keys['Space'] = false; });
            document.getElementById('specialAttackButton').addEventListener('touchstart', (e) => { e.preventDefault(); keys['KeyQ'] = true; }, { passive: false });
            document.getElementById('specialAttackButton').addEventListener('touchend', (e) => { e.preventDefault(); keys['KeyQ'] = false; });

            // Start Button Listener
            startButton.addEventListener('click', startGame);
            startButton.addEventListener('touchend', startGame); // For mobile touch

            // Pause Button Listener
            pauseButton.addEventListener('click', togglePause);
            pauseButton.addEventListener('touchend', togglePause);

            // Volume Slider Listener
            volumeSlider.addEventListener('input', (e) => {
                if (Tone.context && Tone.context.state === 'running') {
                    // Tone.Master.volume.value expects decibels, convert linear 0-1 to dB
                    // A simple conversion: 0 -> -Infinity (mute), 1 -> 0dB (full volume)
                    // Tone.js provides Tone.dbToGain for conversion, but we can do it manually for simplicity
                    // or just set the volume directly if the range is appropriate.
                    // For Tone.js, volume is in dB. A good range is -60 (very quiet) to 0 (max).
                    // Let's map 0-1 to -40dB to 0dB.
                    const linearVolume = parseFloat(e.target.value);
                    Tone.Master.volume.value = Tone.gainToDb(linearVolume);
                    console.log(`Volume set to: ${linearVolume} (dB: ${Tone.Master.volume.value.toFixed(2)})`);
                }
            });
            // Set initial volume
            if (Tone.context && Tone.context.state === 'running') {
                Tone.Master.volume.value = Tone.gainToDb(parseFloat(volumeSlider.value));
            }
            
            // Initial call to animate to ensure rendering starts
            animate();
        }

        function startGame() {
            console.log("Start Game button clicked. Hiding home screen and starting game.");
            homeScreen.style.display = 'none';
            document.getElementById('gameUI').style.display = 'flex';
            document.getElementById('mobileControls').style.display = 'flex';
            miniMapContainer.style.display = 'block'; // Show mini-map
            renderer.domElement.style.display = 'block'; // Show canvas

            // Immediately reset the game visuals and state to appear on screen
            resetGame();

            // Initialize Tone.js and audio components ONLY if they haven't been initialized
            // This happens on the first user gesture (the button click)
            if (!shootSound) { 
                try {
                    Tone.start().then(() => {
                        console.log("AudioContext started successfully on user gesture.");
                        // Initialize all Tone.js synths *inside* this success callback
                        shootSound = new Tone.PolySynth(Tone.MembraneSynth, {
                            pitchDecay: 0.005,
                            octaves: 10,
                            envelope: {
                                attack: 0.001,
                                decay: 0.01,
                                sustain: 0.01,
                                release: 0.01,
                                attackCurve: "exponential"
                            }
                        }).toDestination();

                        explosionSound = new Tone.NoiseSynth({
                            noise: {
                                type: "white"
                            },
                            envelope: {
                                attack: 0.001,
                                decay: 0.2,
                                sustain: 0,
                                release: 0.3
                            }
                        }).toDestination();

                        powerupSound = new Tone.Synth({
                            oscillator: {
                                type: "triangle"
                            },
                            envelope: {
                                attack: 0.005,
                                decay: 0.1,
                                sustain: 0.2,
                                release: 0.5
                            }
                        }).toDestination();

                        specialAttackSound = new Tone.Synth({
                            oscillator: {
                                type: "sawtooth"
                            },
                            envelope: {
                                attack: 0.01,
                                decay: 0.5,
                                sustain: 0.1,
                                release: 0.8
                            },
                            volume: -10 // Louder for impact
                        }).toDestination();


                        bgMusicSynth = new Tone.Synth({
                            oscillator: {
                                type: "sine"
                            },
                            envelope: {
                                attack: 0.1,
                                decay: 0.5,
                                sustain: 0.8,
                                release: 1
                            }
                        }).toDestination();

                        bgMusicLoop = new Tone.Loop(time => { // Assigned to bgMusicLoop
                            bgMusicSynth.triggerAttackRelease("C4", "8n", time);
                            bgMusicSynth.triggerAttackRelease("E4", "8n", time + Tone.Time("8n").toSeconds());
                            bgMusicSynth.triggerAttackRelease("G4", "8n", time + Tone.Time("4n").toSeconds());
                        }, "1n").start(0);
                        bgMusicSynth.volume.value = -20; // Default background music volume

                        Tone.Transport.start();
                        // Set initial master volume based on slider
                        Tone.Master.volume.value = Tone.gainToDb(parseFloat(volumeSlider.value));

                    }).catch(e => {
                        console.error("Failed to start AudioContext on user gesture:", e);
                        showDramaMessage("Audio failed to start. Please try refreshing.", 3000 / 2); // Halved duration
                    });
                } catch (e) {
                    console.error("Error initializing Tone.js:", e);
                    showDramaMessage("Error with audio system. Try refreshing.", 3000 / 2); // Halved duration
                }
            } else {
                // If audio already initialized, just ensure transport is started (in case of previous pause)
                if (Tone.Transport.state !== 'started') {
                    Tone.Transport.start();
                }
            }
            onWindowResize();
            isGameActive = true; // Ensure game is active after starting
        }

        function togglePause() {
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                Tone.Transport.pause();
                showDramaMessage("GAME PAUSED", 0); // Show indefinitely until unpaused
                pauseButton.textContent = "Resume";
            } else {
                Tone.Transport.start();
                dramaOverlay.style.opacity = 0; // Hide pause message
                pauseButton.textContent = "Pause";
            }
            console.log("Game Paused:", isGamePaused);
        }

        function checkOrientation() {
            if (window.innerWidth < 768 && window.innerHeight > window.innerWidth) {
                // Mobile device in portrait mode
                portraitMessage.style.display = 'flex';
                homeScreen.style.display = 'none'; // Hide home screen if in portrait
            } else {
                portraitMessage.style.display = 'none';
                // If not in portrait, ensure home screen is visible for desktop/landscape mobile
                if (!isGameActive) { // Only show home screen if game isn't active
                    homeScreen.style.display = 'flex';
                }
            }
        }

        // --- Game State Management ---
        function resetGame() {
            console.log("Game reset. Starting new round.");
            
            // Clear all active game elements from scene and arrays
            enemies.forEach(e => {
                scene.remove(e.mesh);
                if (e.healthBarSprite) scene.remove(e.healthBarSprite); // Remove health bar
            });
            obstacles.forEach(o => scene.remove(o.mesh));
            powerUps.forEach(p => scene.remove(p));
            explosionParticles.forEach(p => scene.remove(p));
            damageNumbers.forEach(n => scene.remove(n.sprite));

            // Return all active bullets to the pool
            playerBullets.forEach(bullet => disposeBulletMesh(bullet));
            enemyBullets.forEach(bullet => disposeBulletMesh(bullet));

            enemies = [];
            obstacles = [];
            playerBullets = []; // Ensure arrays are empty after disposing
            enemyBullets = [];
            powerUps = [];
            explosionParticles = [];
            damageNumbers = [];

            // Remove dynamic zones from previous game if they exist
            if (greenZoneMesh) { scene.remove(greenZoneMesh.mesh); greenZoneMesh = null; }
            if (blueZoneMesh) { scene.remove(blueZoneMesh.mesh); blueZoneMesh = null; }
            if (hazardZoneMesh) { scene.remove(hazardZoneMesh); hazardZoneMesh = null; } // Also remove fixed hazard zone

            playerHealth = 100;
            playerScore = 0;
            playerInvincible = true; // Player starts invincible
            playerShieldMesh.visible = true; // Show shield at start
            setTimeout(() => {
                playerInvincible = false;
                playerShieldMesh.visible = false;
                console.log("Initial shield deactivated.");
                showDramaMessage("Shield Expired!", 500 / 2); // Reduced duration
            }, 5000); // Invincibility for 5 seconds

            playerDamageMultiplier = 1;
            playerSpeedMultiplier = 1;
            scoreMultiplierActive = false;
            scoreMultiplierEndTime = 0;
            damageMultiplierEndTime = 0;
            speedMultiplierEndTime = 0;
            lastSpecialAttackTime = -SPECIAL_ATTACK_COOLDOWN; // Special attack ready at start
            isMultiTargetActive = false; // Reset multi-target state

            updateUI();
            playerMesh.position.set(0, 0, 0); // Reset player position for the new model

            // Reset player glow
            playerMesh.userData.bodyMaterial.emissive.setHex(0x000000); // No glow
            playerMesh.userData.turretMaterial.emissive.setHex(0x000000); // No glow

            // Clear old obstacles and redraw boundaries for fresh game
            obstacles = []; // Clear array of obstacles
            drawBoundaries(); // Redraw boundaries including fixed hazard zone
            
            // Spawn initial obstacles (which can now be used for cover)
            spawnObstacle(new THREE.Vector3(-30, 2, 0), 5, 4, 5);
            spawnObstacle(new THREE.Vector3(30, 2, 0), 6, 3, 6);
            spawnObstacle(new THREE.Vector3(0, 2, -30), 4, 5, 4);
            spawnObstacle(new THREE.Vector3(0, 2, 30), 7, 2, 7);
            spawnObstacle(new THREE.Vector3(-45, 2, 45), 3, 6, 3);
            
            // --- NEW INTERNAL COVER WALLS ---
            // Central cross-shaped cover
            spawnObstacle(new THREE.Vector3(0, 2, 15), 15, 3, 3); // Horizontal part
            spawnObstacle(new THREE.Vector3(15, 2, 0), 3, 3, 15); // Vertical part
            spawnObstacle(new THREE.Vector3(-15, 2, 0), 3, 3, 15); // Vertical part
            spawnObstacle(new THREE.Vector3(0, 2, -15), 15, 3, 3); // Horizontal part

            // Smaller scattered cover points
            spawnObstacle(new THREE.Vector3(-60, 2, -60), 8, 3, 8);
            spawnObstacle(new THREE.Vector3(60, 2, -60), 8, 3, 8);
            spawnObstacle(new THREE.Vector3(-60, 2, 60), 8, 3, 8);
            spawnObstacle(new THREE.Vector3(60, 2, 60), 8, 3, 8);
            // --- END NEW INTERNAL COVER WALLS ---


            // Spawn one health pack at the start
            spawnRandomPowerUp('healthPack');

            currentWave = 0;
            startNextWave(); // Start the first wave

            showDramaMessage("War Zone: Engage!", 2000 / 2); // Kept longer for impact
            isGameActive = true;
            isGamePaused = false; // Ensure game is not paused on reset
            pauseButton.textContent = "Pause"; // Reset button text
        }

        function startNextWave() {
            currentWave++;
            console.log(`Starting Wave ${currentWave}`);
            
            let waveIndex = currentWave - 1;
            let currentWaveConfig;

            if (waveIndex >= WAVE_CONFIG.length) {
                // Scale difficulty for waves beyond predefined configs
                const baseWaveConfig = WAVE_CONFIG[WAVE_CONFIG.length - 1]; // Use last config as base
                currentWaveConfig = {
                    numEnemies: baseWaveConfig.numEnemies + (currentWave - WAVE_CONFIG.length) * 2, // Add 2 enemies per wave
                    bossChance: Math.min(0.8, baseWaveConfig.bossChance + (currentWave - WAVE_CONFIG.length) * 0.05), // Increase boss chance
                    powerUpChance: baseWaveConfig.powerUpChance // Keep power-up chance
                };
                console.log(`Continuing with scaled Wave ${currentWave} (using dynamic scaling)`);
                showDramaMessage(`Wave ${currentWave} Incoming! Difficulty Scaled!`, 2000 / 2);
            } else {
                currentWaveConfig = WAVE_CONFIG[waveIndex];
                showDramaMessage(`Wave ${currentWave} Incoming!`, 2000 / 2);
            }

            enemiesInCurrentWave = currentWaveConfig.numEnemies;
            enemiesRemainingInWave = currentWaveConfig.numEnemies;
            enemySpawnTimer = 0; // Reset timer for wave-based spawning

            // Full health recovery at the start of each wave
            playerHealth = 100;
            updateUI();
            showDramaMessage("Health Fully Restored!", 500 / 2); // Reduced duration

            // Remove old dynamic zones and spawn new ones for the new wave
            if (greenZoneMesh) { scene.remove(greenZoneMesh.mesh); greenZoneMesh = null; }
            if (blueZoneMesh) { scene.remove(blueZoneMesh.mesh); blueZoneMesh = null; }
            spawnRandomZone('friendly'); // Spawn new green zone
            spawnRandomZone('enemy');    // Spawn new blue zone

            // Spawn initial enemies for the wave
            for (let i = 0; i < Math.min(3, enemiesInCurrentWave); i++) { // Spawn a few at the start
                spawnRandomEnemy(currentWaveConfig.bossChance);
            }

            // Spawn power-ups for the new wave (excluding healthPack as it's handled separately)
            if (Math.random() < currentWaveConfig.powerUpChance) {
                const powerUpTypes = ['health', 'shield', 'damageBoost', 'speedBoost', 'scoreMultiplier', 'nukePack'];
                const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                spawnRandomPowerUp(randomType);
            }
        }

        function gameOver() {
            console.log(`Game Over! Final Score: ${playerScore}`);
            isGameActive = false;
            // Trigger player explosion
            if (playerMesh) {
                spawnExplosion(playerMesh.position, Tone.now());
                scene.remove(playerMesh); // Hide player mesh after explosion
            }
            showDramaMessage("GAME OVER! Score: " + playerScore, 5000 / 2); // Kept longer for impact
            // Hide game elements and show home screen after game over
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('mobileControls').style.display = 'none';
            miniMapContainer.style.display = 'none'; // Hide mini-map
            renderer.domElement.style.display = 'none';
            if (Tone.Transport.state === 'started') {
                Tone.Transport.stop(); // Stop audio on game over
            }
            setTimeout(() => {
                homeScreen.style.display = 'flex';
                checkOrientation(); // Re-check orientation for home screen
            }, 2500); // Halved delay
        }

        function victory() {
            // This function is no longer intended to end the game but could be repurposed
            // for, e.g., showing a "Wave Cleared!" message more prominently if needed.
            // For an endless game, we just continue to the next wave.
            console.log(`Wave ${currentWave} Cleared! Preparing for next wave.`);
        }

        function updateUI() {
            healthFill.style.width = playerHealth + '%';
            healthFill.style.background = `linear-gradient(to right, #00ff00 ${playerHealth}%, #ff0000 ${playerHealth}%)`;
            scoreDisplay.textContent = `Score: ${playerScore} | Wave: ${currentWave}`;
        }

        // --- Helper Functions ---
        function onWindowResize() {
            // Adjusted to full window size
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); // Adjusted to full window size
            
            // Resize mini-map canvas
            miniMapCanvas.width = miniMapContainer.offsetWidth;
            miniMapCanvas.height = miniMapContainer.offsetHeight;

            checkOrientation(); // Re-check orientation on resize
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        /**
         * Function to get the bounding box of a Three.js object (mesh or group).
         * This is essential for accurate collision detection.
         * @param {THREE.Object3D} object - The Three.js object to get the bounding box for.
         * @returns {THREE.Box3} The bounding box of the object.
         */
        function getBoundingBox(object) {
            const box = new THREE.Box3().setFromObject(object);
            return box;
        }

        function drawBoundaries() {
            // Remove existing boundaries if resetting
            scene.children.filter(obj => obj.userData.isBoundary).forEach(obj => scene.remove(obj));

            const WALL_HEIGHT = 10;
            const WALL_THICKNESS = 5; // Increased wall thickness
            // Updated wall material for better visibility
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00FF00, // Bright green color
                emissive: 0x00FF00, // Matching emissive color for glow
                emissiveIntensity: 3.5, /* Increased emissive intensity */
                shininess: 30 
            });

            // North Wall (-Z)
            const northWall = new THREE.Mesh(
                new THREE.BoxGeometry(WORLD_BOUNDARY * 2 + WALL_THICKNESS * 2, WALL_HEIGHT, WALL_THICKNESS),
                wallMaterial
            );
            northWall.position.set(0, WALL_HEIGHT / 2, WORLD_MIN - WALL_THICKNESS / 2);
            northWall.userData.isBoundary = true;
            obstacles.push({ mesh: northWall, health: Infinity }); // Make boundaries unbreakable
            scene.add(northWall);

            // South Wall (+Z)
            const southWall = new THREE.Mesh(
                new THREE.BoxGeometry(WORLD_BOUNDARY * 2 + WALL_THICKNESS * 2, WALL_HEIGHT, WALL_THICKNESS),
                wallMaterial
            );
            southWall.position.set(0, WALL_HEIGHT / 2, WORLD_BOUNDARY + WALL_THICKNESS / 2);
            southWall.userData.isBoundary = true;
            obstacles.push({ mesh: southWall, health: Infinity }); // Make boundaries unbreakable
            scene.add(southWall);

            // West Wall (-X)
            const westWall = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, WORLD_BOUNDARY * 2),
                wallMaterial
            );
            westWall.position.set(WORLD_MIN - WALL_THICKNESS / 2, WALL_HEIGHT / 2, 0);
            westWall.userData.isBoundary = true;
            obstacles.push({ mesh: westWall, health: Infinity }); // Make boundaries unbreakable
            scene.add(westWall);

            // East Wall (+X)
            const eastWall = new THREE.Mesh(
                new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, WORLD_BOUNDARY * 2),
                wallMaterial
            );
            eastWall.position.set(WORLD_BOUNDARY + WALL_THICKNESS / 2, WALL_HEIGHT / 2, 0);
            eastWall.userData.isBoundary = true;
            obstacles.push({ mesh: eastWall, health: Infinity }); // Make boundaries unbreakable
            scene.add(eastWall);

            // Red zone is fixed in the middle and spawned only once here
            spawnFixedHazardZone(new THREE.Vector3(0, 0.1, 0));
        }

        /**
         * Spawns the fixed hazard zone in the middle of the map.
         * @param {THREE.Vector3} position - The position to spawn the hazard zone.
         */
        function spawnFixedHazardZone(position) {
            if (hazardZoneMesh) {
                scene.remove(hazardZoneMesh); // Remove existing one if resetting
            }
            hazardZoneCenter.copy(position);
            const geometry = new THREE.CircleGeometry(hazardZoneRadius, 32);
            const material = new THREE.MeshBasicMaterial({ color: HAZARD_ZONE_COLOR, opacity: 0.4, transparent: true, side: THREE.DoubleSide });
            const circle = new THREE.Mesh(geometry, material);
            circle.rotation.x = -Math.PI / 2;
            circle.position.copy(hazardZoneCenter);
            scene.add(circle);
            hazardZoneMesh = circle;
            console.log(`Fixed Hazard zone spawned at X:${position.x.toFixed(2)}, Z:${position.z.toFixed(2)} with radius ${hazardZoneRadius}`);
        }

        /**
         * Spawns a dynamic zone (friendly or enemy) at a random location.
         * @param {string} type - 'friendly' for green (health), 'enemy' for blue (multi-target).
         */
        function spawnRandomZone(type) {
            // Keep zones away from edges and center to avoid overlap with fixed hazard zone
            const zoneSpawnPadding = 40;
            const spawnRange = (WORLD_BOUNDARY - WORLD_MIN) - (zoneSpawnPadding * 2);
            const spawnX = Math.random() * spawnRange + WORLD_MIN + zoneSpawnPadding;
            const spawnZ = Math.random() * spawnRange + WORLD_MIN + zoneSpawnPadding;
            const position = new THREE.Vector3(spawnX, 0.1, spawnZ);
            const radius = 20;

            let color;
            let mesh;
            if (type === 'friendly') {
                color = FRIENDLY_ZONE_COLOR; // Green
                const geometry = new THREE.CircleGeometry(radius, 32);
                const material = new THREE.MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.copy(position);
                scene.add(mesh);
                greenZoneMesh = { mesh: mesh, position: position, radius: radius };
                console.log(`Green zone spawned at X:${position.x.toFixed(2)}, Z:${position.z.toFixed(2)}`);
            } else if (type === 'enemy') {
                color = ENEMY_ZONE_COLOR; // Blue
                const geometry = new THREE.CircleGeometry(radius, 32);
                const material = new THREE.MeshBasicMaterial({ color: color, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
                mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = -Math.PI / 2;
                mesh.position.copy(position);
                scene.add(mesh);
                blueZoneMesh = { mesh: mesh, position: position, radius: radius };
                console.log(`Blue zone spawned at X:${position.x.toFixed(2)}, Z:${position.z.toFixed(2)}`);
            }
        }

        /**
         * Spawns an obstacle.
         * @param {THREE.Vector3} position - The position to spawn the obstacle.
         * @param {number} width - Width of the obstacle.
         * @param {number} height - Height of the obstacle.
         * @param {number} depth - Depth of the obstacle.
         */
        function spawnObstacle(position, width, height, depth) {
            const isCube = Math.random() > 0.5; // Randomly choose between cube and dodecahedron
            let geometry, health;
            let originalColor = OBSTACLE_COLOR; // Store original color for reset

            if (isCube) {
                geometry = new THREE.BoxGeometry(width, height, depth);
                health = Infinity; // Unbreakable
                console.log("Spawned unbreakable cuboid obstacle.");
            } else {
                geometry = new THREE.DodecahedronGeometry(width / 2); // Use width for radius
                health = 100; // Breakable
                console.log("Spawned breakable dodecahedron obstacle.");
            }
            
            const mesh = new THREE.Mesh(
                geometry,
                new THREE.MeshPhongMaterial({ color: originalColor }) // Use original color
            );
            mesh.position.copy(position);
            mesh.position.y = height / 2; // Position correctly on the ground
            scene.add(mesh);
            obstacles.push({ mesh: mesh, health: health, originalColor: originalColor, lastHitTime: 0 }); // Store original color and last hit time
            console.log(`Spawned obstacle at X:${position.x.toFixed(2)}, Y:${position.y.toFixed(2)}, Z:${position.z.toFixed(2)}`);
        }

        function spawnRandomEnemy(bossChance) {
            const spawnRange = WORLD_BOUNDARY - WORLD_MIN - 20; // Keep enemies away from edges
            const enemyRadius = 2; // Radius of the enemy OctahedronGeometry(2)
            const enemyApproxHeight = 2; // Approximate height of the enemy mesh

            let validPosition = false;
            let attempts = 0;
            const minSpawnDistanceToPlayer = 40; // Minimum distance from player

            let spawnPosition = new THREE.Vector3(); // Declare outside loop

            while (!validPosition && attempts < 20) { // Increased attempts for better chances
                const currentSpawnX = Math.random() * spawnRange + WORLD_MIN + 10;
                const currentSpawnZ = Math.random() * spawnRange + WORLD_MIN + 10;
                spawnPosition.set(currentSpawnX, enemyApproxHeight / 2, currentSpawnZ); // Set Y to half enemy height

                let tooClose = false;

                // Check distance to player
                if (playerMesh.position.distanceTo(spawnPosition) < minSpawnDistanceToPlayer) {
                    tooClose = true;
                } else {
                    // Create a temporary bounding box for the potential new enemy at the test spawn position
                    const tempEnemyBox = new THREE.Box3(
                        new THREE.Vector3(spawnPosition.x - enemyRadius, spawnPosition.y - enemyApproxHeight / 2, spawnPosition.z - enemyRadius),
                        new THREE.Vector3(spawnPosition.x + enemyRadius, spawnPosition.y + enemyApproxHeight / 2, spawnPosition.z + enemyRadius)
                    );

                    // Check collision with existing obstacles
                    for (const obstacle of obstacles) {
                        if (!obstacle.mesh.visible || obstacle.health <= 0) continue; // Skip destroyed/invisible obstacles

                        const obstacleBox = getBoundingBox(obstacle.mesh);
                        if (tempEnemyBox.intersectsBox(obstacleBox)) {
                            tooClose = true;
                            break;
                        }
                    }
                }
                
                if (!tooClose) {
                    validPosition = true;
                }
                attempts++;
            }
            if (validPosition) {
                spawnEnemy(spawnPosition, Math.random() < bossChance);
            } else {
                console.warn("Could not find a valid spawn position for enemy after multiple attempts.");
            }
        }

        function spawnEnemy(position, isBoss = false) {
            // Enemy Model - More angular with a glowing eye and spikes
            const enemyGroup = new THREE.Group();

            const enemyBodyGeometry = new THREE.OctahedronGeometry(2); // Main angular body
            const enemyBodyMaterial = new THREE.MeshPhongMaterial({ color: ENEMY_COLOR, shininess: 70 });
            const enemyBody = new THREE.Mesh(enemyBodyGeometry, enemyBodyMaterial);
            enemyBody.position.y = 1;
            enemyGroup.add(enemyBody);

            // Spikes (4 cones)
            const spikeGeometry = new THREE.ConeGeometry(0.5, 2, 4); // Base radius, height, radial segments
            const spikeMaterial = new THREE.MeshPhongMaterial({ color: 0x880000, shininess: 50 }); // Darker red
            
            const spike1 = new THREE.Mesh(spikeGeometry, spikeMaterial);
            spike1.rotation.z = Math.PI / 2;
            spike1.position.set(1.5, 1, 0); // Right
            enemyGroup.add(spike1);

            const spike2 = new THREE.Mesh(spikeGeometry, spikeMaterial);
            spike2.rotation.z = -Math.PI / 2;
            spike2.position.set(-1.5, 1, 0); // Left
            enemyGroup.add(spike2);

            const spike3 = new THREE.Mesh(spikeGeometry, spikeMaterial);
            spike3.rotation.x = Math.PI / 2;
            spike3.position.set(0, 1, 1.5); // Back
            enemyGroup.add(spike3);

            const spike4 = new THREE.Mesh(spikeGeometry, spikeMaterial);
            spike4.rotation.x = -Math.PI / 2;
            spike4.position.set(0, 1, -1.5); // Front
            enemyGroup.add(spike4);

            // Enemy Eye - Changed to MeshPhongMaterial
            const enemyEyeGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const enemyEyeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00, 
                emissive: 0x00ff00, 
                emissiveIntensity: 1.5 // Emissive intensity for the glow
            }); 
            const enemyEye = new THREE.Mesh(enemyEyeGeometry, enemyEyeMaterial);
            enemyEye.position.set(0, 1, -2.5); // Position in front of the body, further out
            enemyGroup.add(enemyEye);

            enemyGroup.position.copy(position);
            enemyGroup.userData.isBoss = isBoss;
            scene.add(enemyGroup); // Add the group to the scene

            const maxHealth = isBoss ? 200 : 100;
            // Apply dynamic difficulty scaling
            let currentWaveConfig = WAVE_CONFIG[Math.min(currentWave - 1, WAVE_CONFIG.length - 1)];
            if (currentWave -1 >= WAVE_CONFIG.length) {
                 currentWaveConfig = {
                    numEnemies: currentWaveConfig.numEnemies + (currentWave - WAVE_CONFIG.length) * 2,
                    bossChance: Math.min(0.8, currentWaveConfig.bossChance + (currentWave - WAVE_CONFIG.length) * 0.05),
                    powerUpChance: currentWaveConfig.powerUpChance
                };
            }
            const difficultyScale = 1 + (currentWave -1) * 0.1; // 10% increase per wave
            const finalHealth = maxHealth * difficultyScale;
            const finalSpeed = (isBoss ? PLAYER_BASE_SPEED * 0.7 : PLAYER_BASE_SPEED * 0.9) * (1 + (currentWave -1) * 0.05);
            const finalDamage = (isBoss ? ENEMY_BULLET_DAMAGE * 1.5 : ENEMY_BULLET_DAMAGE) * (1 + (currentWave -1) * 0.05);

            const enemyData = { 
                mesh: enemyGroup, 
                health: finalHealth, 
                maxHealth: finalHealth, // Store max health for health bar
                speed: finalSpeed,
                damage: finalDamage,
                lastShotTime: performance.now() / 1000,
                healthBarSprite: createHealthBarSprite(finalHealth) // Create health bar sprite
            };
            enemies.push(enemyData);
            scene.add(enemyData.healthBarSprite); // Add health bar to scene
            console.log(`Spawned ${isBoss ? 'Boss' : 'Enemy'} at X:${position.x.toFixed(2)}, Y:${position.y.toFixed(2)}, Z:${position.z.toFixed(2)} with health: ${finalHealth.toFixed(0)}`);
        }

        /**
         * Creates a Three.js Sprite to act as a health bar.
         * @param {number} maxHealth - The maximum health for the entity.
         * @returns {THREE.Sprite} The health bar sprite.
         */
        function createHealthBarSprite(maxHealth) {
            const barWidth = 64;
            const barHeight = 8;
            const canvas = document.createElement('canvas');
            canvas.width = barWidth;
            canvas.height = barHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#555555'; // Background of the bar
            ctx.fillRect(0, 0, barWidth, barHeight);
            ctx.fillStyle = '#00ff00'; // Initial fill color (green)
            ctx.fillRect(0, 0, barWidth, barHeight);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(10, 2, 1); // Scale sprite in 3D space
            sprite.userData.maxHealth = maxHealth;
            sprite.userData.currentHealth = maxHealth;
            return sprite;
        }

        /**
         * Updates the visual state of a health bar sprite.
         * @param {THREE.Sprite} healthBarSprite - The health bar sprite to update.
         * @param {number} currentHealth - The current health value.
         */
        function updateHealthBarSprite(healthBarSprite, currentHealth) {
            healthBarSprite.userData.currentHealth = currentHealth;
            const maxHealth = healthBarSprite.userData.maxHealth;
            const healthRatio = Math.max(0, currentHealth / maxHealth); // Ensure not negative

            const canvas = healthBarSprite.material.map.image;
            const ctx = canvas.getContext('2d');
            const barWidth = canvas.width;
            const barHeight = canvas.height;

            ctx.clearRect(0, 0, barWidth, barHeight);
            ctx.fillStyle = '#555555'; // Background
            ctx.fillRect(0, 0, barWidth, barHeight);

            // Health gradient
            const gradient = ctx.createLinearGradient(0, 0, barWidth, 0);
            gradient.addColorStop(0, 'red');
            gradient.addColorStop(0.5, 'yellow');
            gradient.addColorStop(1, 'lime');
            ctx.fillStyle = gradient;
            
            ctx.fillRect(0, 0, barWidth * healthRatio, barHeight);
            healthBarSprite.material.map.needsUpdate = true;
        }

        /**
         * Spawns a power-up at a given position and type.
         * @param {THREE.Vector3} position - The position to spawn the power-up.
         * @param {string} type - The type of power-up ('health', 'shield', etc.).
         */
        function spawnPowerUp(position, type) {
            let color;
            let shape;
            switch (type) {
                case 'health': color = 0x00ff00; shape = new THREE.SphereGeometry(1, 12, 12); break;
                case 'shield': color = 0x00ffff; shape = new THREE.SphereGeometry(1, 12, 12); break;
                case 'damageBoost': color = 0xFFA500; shape = new THREE.SphereGeometry(1, 12, 12); break; // Orange for damage boost
                case 'speedBoost': color = 0xFFFF00; shape = new THREE.SphereGeometry(1, 12, 12); break; // Yellow for speed boost
                case 'scoreMultiplier': color = 0x8A2BE2; shape = new THREE.SphereGeometry(1, 12, 12); break; // Purple for score multiplier
                case 'healthPack': color = 0x00ff00; shape = new THREE.BoxGeometry(1.5, 1.5, 1.5); break; // Green cube for HP pack
                case 'nukePack': color = 0x800080; shape = new THREE.OctahedronGeometry(1.5); break; // Purple octahedron for Nuke pack
                default: color = 0xffffff; shape = new THREE.SphereGeometry(1, 12, 12);
            }
            const mesh = new THREE.Mesh(
                shape,
                new THREE.MeshPhongMaterial({ color })
            );
            mesh.position.copy(position);
            mesh.userData.type = type;
            powerUps.push(mesh);
            scene.add(mesh);
            console.log(`Spawned ${type} power-up at X:${position.x.toFixed(2)}, Y:${position.y.toFixed(2)}, Z:${position.z.toFixed(2)}`);
        }

        /**
         * Spawns a power-up of a given type at a random position within the world boundaries.
         * @param {string} type - The type of power-up to spawn.
         */
        function spawnRandomPowerUp(type) {
            const spawnRange = WORLD_BOUNDARY - WORLD_MIN - 20; // Keep power-ups away from edges
            const spawnX = Math.random() * spawnRange + WORLD_MIN + 10;
            const spawnZ = Math.random() * spawnRange + WORLD_MIN + 10;
            spawnPowerUp(new THREE.Vector3(spawnX, 1, spawnZ), type);
        }

        /**
         * Gets a bullet mesh from the pool or creates a new one if the pool is empty.
         * @param {boolean} isPlayerBullet - True if it's a player bullet, false for enemy.
         * @returns {THREE.Mesh} The bullet mesh.
         */
        function getBulletMesh(isPlayerBullet) {
            let bullet;
            if (bulletPool.length > 0) {
                bullet = bulletPool.pop(); 
                bullet.visible = true;
                console.log("Reusing bullet from pool. Pool size:", bulletPool.length);
            } else {
                const geometry = new THREE.SphereGeometry(0.5, 8, 8); // Slightly larger bullet
                // Changed to MeshPhongMaterial to support emissive
                const material = new THREE.MeshPhongMaterial({ blending: THREE.AdditiveBlending }); 
                bullet = new THREE.Mesh(geometry, material);
                console.log("Creating new bullet. Pool size:", bulletPool.length);
            }
            // Set material color based on bullet type
            bullet.material.color.setHex(isPlayerBullet ? 0x00ffff : 0xffff00);
            bullet.material.emissive.setHex(isPlayerBullet ? 0x00ffff : 0xffff00); // Emissive for glow
            return bullet;
        }

        /**
         * Returns a bullet mesh to the pool and hides it.
         * @param {THREE.Mesh} bullet - The bullet mesh to dispose.
         */
        function disposeBulletMesh(bullet) {
            scene.remove(bullet); // Remove from scene
            bullet.visible = false; // Hide it
            if (bulletPool.length < MAX_BULLETS_IN_POOL) {
                bulletPool.push(bullet); // Add back to pool if not full
                console.log("Bullet returned to pool. Pool size:", bulletPool.length);
            } else {
                // If pool is full, dispose of geometry and material to free memory
                if (bullet.geometry) bullet.geometry.dispose();
                if (bullet.material) bullet.material.dispose();
                console.log("Bullet disposed (pool full).");
            }
        }

        function shootBullet(origin, target, isPlayerBullet) {
            const bullet = getBulletMesh(isPlayerBullet);
            bullet.position.copy(origin);

            const direction = new THREE.Vector3().subVectors(target, origin).normalize();
            bullet.userData = { direction: direction, speed: BULLET_SPEED, damage: isPlayerBullet ? (PLAYER_BASE_BULLET_DAMAGE * playerDamageMultiplier) : ENEMY_BULLET_DAMAGE };

            if (isPlayerBullet) {
                playerBullets.push(bullet);
                console.log(`Player shot bullet from X:${origin.x.toFixed(2)}, Z:${origin.z.toFixed(2)} towards X:${target.x.toFixed(2)}, Z:${target.z.toFixed(2)} (Damage: ${bullet.userData.damage})`);
            } else {
                enemyBullets.push(bullet);
                console.log(`Enemy shot bullet from X:${origin.x.toFixed(2)}, Z:${origin.z.toFixed(2)} towards X:${target.x.toFixed(2)}, Z:${target.z.toFixed(2)}`);
            }
            scene.add(bullet);
            if (Tone.context && Tone.context.state === 'running') { // Check Tone.context exists and is running
                shootSound.triggerAttackRelease("C2", "16n");
            }
        }

        function performSpecialAttack() {
            const currentTime = performance.now() / 1000;
            if (currentTime - lastSpecialAttackTime < SPECIAL_ATTACK_COOLDOWN) {
                console.log("Special attack on cooldown.");
                showDramaMessage(`Special Attack Cooldown: ${Math.ceil(SPECIAL_ATTACK_COOLDOWN - (currentTime - lastSpecialAttackTime))}s`, 500 / 2); // Reduced duration
                return;
            }

            console.log("Performing special attack!");
            if (Tone.context && Tone.context.state === 'running') { // Check Tone.context exists and is running
                specialAttackSound.triggerAttackRelease("C4", "1n"); // A long, impactful sound
            }
            showDramaMessage("Special Attack!", 500 / 2); // Reduced duration
            lastSpecialAttackTime = currentTime;

            const attackRadius = 30; // Radius of the special attack
            const attackDamage = 150; // Damage of the special attack

            // Visual effect for special attack (simple expanding sphere)
            const attackSphereGeometry = new THREE.SphereGeometry(1, 32, 32);
            const attackSphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, opacity: 0.5, transparent: true, blending: THREE.AdditiveBlending });
            const attackSphere = new THREE.Mesh(attackSphereGeometry, attackSphereMaterial);
            attackSphere.position.copy(playerMesh.position);
            scene.add(attackSphere);

            let scale = 1;
            const animateAttack = () => {
                if (scale < attackRadius) {
                    attackSphere.scale.set(scale, scale, scale);
                    attackSphere.material.opacity = 0.5 - (scale / attackRadius) * 0.5;
                    scale += 2; // Expand quickly
                    requestAnimationFrame(animateAttack);
                } else {
                    scene.remove(attackSphere);
                }
            };
            animateAttack();

            enemies.forEach(enemy => {
                if (playerMesh.position.distanceTo(enemy.mesh.position) < attackRadius) {
                    enemy.health -= attackDamage;
                    spawnDamageNumber(attackDamage, enemy.mesh.position, 0x00ff00); // Green for special attack damage
                    console.log(`Special attack hit enemy. Enemy health: ${enemy.health}`);
                }
            });
            // Also damage obstacles
            obstacles.forEach(obstacle => {
                // Check if the obstacle is breakable before applying damage
                if (obstacle.health !== Infinity && playerMesh.position.distanceTo(obstacle.mesh.position) < attackRadius) {
                    obstacle.health -= attackDamage;
                    spawnDamageNumber(attackDamage, obstacle.mesh.position, 0x00ff00);
                    console.log(`Special attack hit obstacle. Obstacle health: ${obstacle.health}`);
                }
            });
        }


        function updatePlayer(delta) {
            if (!playerMesh) return;

            const currentSpeed = PLAYER_BASE_SPEED * playerSpeedMultiplier;
            const moveAmount = currentSpeed * delta;
            
            const playerMovementVector = new THREE.Vector3(0, 0, 0);
            if (keys['KeyW']) { playerMovementVector.z -= moveAmount; }
            if (keys['KeyS']) { playerMovementVector.z += moveAmount; }
            if (keys['KeyA']) { playerMovementVector.x -= moveAmount; }
            if (keys['KeyD']) { playerMovementVector.x += moveAmount; }

            const playerCurrentPos = playerMesh.position.clone();
            const playerNextPosX = playerCurrentPos.x + playerMovementVector.x;
            const playerNextPosZ = playerCurrentPos.z + playerMovementVector.z;

            // Get player's current bounding box
            const playerBox = getBoundingBox(playerMesh);

            // X-axis collision check
            let collisionX = false;
            if (playerMovementVector.x !== 0) {
                const potentialPlayerBoxX = playerBox.clone();
                potentialPlayerBoxX.translate(new THREE.Vector3(playerMovementVector.x, 0, 0));

                for (const obstacle of obstacles) {
                    // Skip if the obstacle is not visible or already destroyed
                    if (!obstacle.mesh.visible || obstacle.health <= 0) continue;

                    const obstacleBox = getBoundingBox(obstacle.mesh);
                    if (potentialPlayerBoxX.intersectsBox(obstacleBox)) {
                        collisionX = true;
                        break;
                    }
                }
            }
            if (!collisionX) {
                playerMesh.position.x = playerNextPosX;
            }

            // Z-axis collision check
            let collisionZ = false;
            if (playerMovementVector.z !== 0) {
                const potentialPlayerBoxZ = playerBox.clone();
                potentialPlayerBoxZ.translate(new THREE.Vector3(0, 0, playerMovementVector.z));

                for (const obstacle of obstacles) {
                     // Skip if the obstacle is not visible or already destroyed
                    if (!obstacle.mesh.visible || obstacle.health <= 0) continue;

                    const obstacleBox = getBoundingBox(obstacle.mesh);
                    if (potentialPlayerBoxZ.intersectsBox(obstacleBox)) {
                        collisionZ = true;
                        break;
                    }
                }
            }
            if (!collisionZ) {
                playerMesh.position.z = playerNextPosZ;
            }

            // Clamp player position to world boundaries AFTER checking internal collisions
            playerMesh.position.x = Math.max(WORLD_MIN, Math.min(WORLD_BOUNDARY, playerMesh.position.x));
            playerMesh.position.z = Math.max(WORLD_MIN, Math.min(WORLD_BOUNDARY, playerMesh.position.z));

            // Player bobbing animation
            playerMesh.position.y = 1 + Math.sin(performance.now() * 0.005) * 0.2; // Subtle bobbing

            // Player turret rotation to face closest enemy when shooting
            const playerTurretTop = playerMesh.children[1].children[0]; // Access the turret top
            let closestEnemy = null;
            let minDistance = Infinity;
            enemies.forEach(enemy => {
                const distance = playerMesh.position.distanceTo(enemy.mesh.position);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestEnemy = enemy;
                }
            });

            if (closestEnemy) {
                // Calculate direction vector from player's turret world position to enemy's world position
                const turretWorldPosition = new THREE.Vector3();
                playerTurretTop.getWorldPosition(turretWorldPosition); // Get the turret's world position

                const targetVector = new THREE.Vector3().subVectors(closestEnemy.mesh.position, turretWorldPosition);
                
                // Convert world direction to local direction relative to playerMesh for turret rotation
                // The turret is a child of playerMesh.playerTurretBase which is a child of playerMesh.
                // The playerTurretTop is a child of playerTurretBase.
                // The playerBarrel is a child of playerTurretTop.
                // So, to get the correct local target vector for playerTurretTop, we need its parent's (playerTurretBase's) world position,
                // and then calculate the vector to the enemy from there, then convert it to local space.
                
                const playerTurretBaseWorldPosition = new THREE.Vector3();
                playerMesh.children[1].getWorldPosition(playerTurretBaseWorldPosition);

                const localTargetVector = new THREE.Vector3().subVectors(closestEnemy.mesh.position, playerTurretBaseWorldPosition);
                playerMesh.children[1].worldToLocal(localTargetVector); // Convert to local space of playerTurretBase

                // Calculate angle for turret rotation around Y-axis based on localTargetVector
                // The turret's barrel points along its local negative Z-axis when rotation.y is 0.
                // Math.atan2(x, z) gives the angle from the positive Z-axis towards the positive X-axis.
                // We want the barrel (which is aligned with negative Z) to point towards the target.
                let targetAngle = Math.atan2(localTargetVector.x, localTargetVector.z);
                
                // Smoothly interpolate the turret's Y-rotation
                playerTurretTop.rotation.y = THREE.MathUtils.lerp(playerTurretTop.rotation.y, targetAngle, 0.1);
            } else {
                // If no enemies, reset turret to face forward (0 rotation relative to player base)
                playerTurretTop.rotation.y = THREE.MathUtils.lerp(playerTurretTop.rotation.y, 0, 0.1);
            }


            // Apply green zone health recovery
            if (greenZoneMesh && playerMesh.position.distanceTo(greenZoneMesh.position) < greenZoneMesh.radius) {
                playerHealth = Math.min(100, playerHealth + HEALTH_RECOVERY_RATE * delta);
                updateUI();
            }

            // Apply blue zone multi-target effect
            const currentTime = performance.now() / 1000;
            if (blueZoneMesh && playerMesh.position.distanceTo(blueZoneMesh.position) < blueZoneMesh.radius) {
                if (!isMultiTargetActive) {
                    isMultiTargetActive = true;
                    multiTargetEndTime = currentTime + MULTI_TARGET_DURATION;
                    showDramaMessage("Multi-Target Active!", 500 / 2); // Reduced duration
                    console.log("Multi-target activated.");
                }
            } else {
                // If player leaves the zone, deactivate immediately if active
                if (isMultiTargetActive && currentTime > multiTargetEndTime) {
                    isMultiTargetActive = false;
                    showDramaMessage("Multi-Target Expired!", 500 / 2); // Reduced duration
                    console.log("Multi-target deactivated.");
                }
            }
            // Ensure multi-target deactivates if time runs out even if player is still in zone
            if (isMultiTargetActive && currentTime > multiTargetEndTime) {
                isMultiTargetActive = false;
                showDramaMessage("Multi-Target Expired!", 500 / 2); // Reduced duration
                console.log("Multi-target deactivated.");
            }


            // Player shooting
            if (keys['Space'] && performance.now() / 1000 - lastPlayerShotTime > playerShootCooldown) {
                if (isMultiTargetActive) {
                    // Multi-target shooting
                    const sortedEnemies = [...enemies].sort((a, b) =>
                        playerMesh.position.distanceTo(a.mesh.position) - playerMesh.position.distanceTo(b.mesh.position)
                    );
                    const targets = sortedEnemies.slice(0, MULTI_TARGET_COUNT);
                    if (targets.length > 0) {
                        targets.forEach(enemy => {
                            // Shoot from the barrel's position
                            const barrelWorldPos = new THREE.Vector3();
                            // Get barrel's world position (playerMesh -> playerTurretBase -> playerTurretTop -> playerBarrel)
                            playerMesh.children[1].children[0].children[0].getWorldPosition(barrelWorldPos);
                            shootBullet(barrelWorldPos, enemy.mesh.position, true);
                        });
                        lastPlayerShotTime = performance.now() / 1000;
                    }
                } else {
                    // Single target shooting
                    let closestEnemy = null;
                    let minDistance = Infinity;
                    enemies.forEach(enemy => {
                        const distance = playerMesh.position.distanceTo(enemy.mesh.position);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestEnemy = enemy;
                        }
                    });

                    if (closestEnemy) {
                        // Shoot from the barrel's position
                        const barrelWorldPos = new THREE.Vector3();
                        // Get barrel's world position (playerMesh -> playerTurretBase -> playerTurretTop -> playerBarrel)
                        playerMesh.children[1].children[0].children[0].getWorldPosition(barrelWorldPos);
                        shootBullet(barrelWorldPos, closestEnemy.mesh.position, true);
                        lastPlayerShotTime = performance.now() / 1000;
                    }
                }
            }

            // Special attack
            if (keys['KeyQ']) {
                performSpecialAttack();
            }

            // Apply hazard zone damage
            if (hazardZoneMesh && playerMesh.position.distanceTo(hazardZoneCenter) < hazardZoneRadius) {
                const damageThisFrame = HAZARD_DAMAGE_RATE * delta;
                if (!playerInvincible) {
                    playerHealth -= damageThisFrame;
                    updateUI();
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
            }

            // Update power-up durations and player glow
            const playerBodyMaterial = playerMesh.userData.bodyMaterial;
            const playerTurretMaterial = playerMesh.userData.turretMaterial;
            const originalPlayerColor = new THREE.Color(PLAYER_COLOR);

            if (scoreMultiplierActive && currentTime > scoreMultiplierEndTime) {
                scoreMultiplierActive = false;
                showDramaMessage("Score Multiplier Expired!", 500 / 2);
                console.log("Score multiplier deactivated.");
            }

            if (playerDamageMultiplier > 1) {
                if (currentTime > damageMultiplierEndTime) {
                    playerDamageMultiplier = 1;
                    playerBodyMaterial.emissive.setHex(0x000000); // Remove glow
                    playerTurretMaterial.emissive.setHex(0x000000);
                    playerBodyMaterial.color.copy(originalPlayerColor); // Reset color
                    playerTurretMaterial.color.setHex(0x0088ff); // Reset turret top color
                    showDramaMessage("Damage Boost Expired!", 500 / 2);
                    console.log("Damage boost deactivated.");
                } else {
                    // Damage boost active - pulse orange glow
                    const pulse = Math.sin(currentTime * 10) * 0.5 + 0.5; // 0 to 1
                    playerBodyMaterial.emissive.setScalar(pulse * 1.5); // Stronger glow
                    playerBodyMaterial.emissive.setHex(0xFFA500); // Orange glow for damage
                }
            } else if (playerSpeedMultiplier > 1) {
                if (currentTime > speedMultiplierEndTime) {
                    playerSpeedMultiplier = 1;
                    playerBodyMaterial.emissive.setHex(0x000000); // Remove glow
                    playerTurretMaterial.emissive.setHex(0x000000);
                    playerBodyMaterial.color.copy(originalPlayerColor); // Reset color
                    playerTurretMaterial.color.setHex(0x0088ff); // Reset turret top color
                    showDramaMessage("Speed Boost Expired!", 500 / 2);
                    console.log("Speed boost deactivated.");
                } else {
                    // Speed boost active - pulse yellow glow
                    const pulse = Math.sin(currentTime * 10) * 0.5 + 0.5; // 0 to 1
                    playerBodyMaterial.emissive.setScalar(pulse * 1.5);
                    playerBodyMaterial.emissive.setHex(0xFFFF00); // Yellow glow for speed
                }
            } else {
                // No boosts active, ensure no glow
                playerBodyMaterial.emissive.setHex(0x000000);
                playerTurretMaterial.emissive.setHex(0x000000);
                playerBodyMaterial.color.copy(originalPlayerColor); // Ensure original color
                playerTurretMaterial.color.setHex(0x0088ff); // Ensure original turret color
            }
        }

        function updateBullets(delta) {
            // Player bullets
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                bullet.position.addScaledVector(bullet.userData.direction, bullet.userData.speed * delta);

                // Check collision with enemies
                let hitEnemy = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (bullet.position.distanceTo(enemies[j].mesh.position) < 2) {
                        enemies[j].health -= bullet.userData.damage;
                        spawnDamageNumber(bullet.userData.damage, enemies[j].mesh.position);
                        updateHealthBarSprite(enemies[j].healthBarSprite, enemies[j].health); // Update health bar
                        disposeBulletMesh(bullet); // Return bullet to pool
                        playerBullets.splice(i, 1);
                        hitEnemy = true;
                        console.log(`Player bullet hit enemy. Enemy health: ${enemies[j].health}`);
                        break;
                    }
                }
                if (hitEnemy) continue;

                // Check collision with obstacles
                let hitObstacle = false;
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    // Skip if the obstacle is not visible or already destroyed
                    // Also check if obstacle has health Infinity (unbreakable)
                    if (!obstacles[j].mesh.visible || obstacles[j].health <= 0) continue;

                    const obstacleBox = getBoundingBox(obstacles[j].mesh);
                    const bulletSphere = new THREE.Sphere(bullet.position, bullet.geometry.parameters.radius);
                    if (obstacleBox.intersectsSphere(bulletSphere)) {
                        // Only damage if health is not Infinity (i.e., it's a breakable obstacle)
                        if (obstacles[j].health !== Infinity) { 
                            obstacles[j].health -= bullet.userData.damage; // Bullets damage obstacles
                            spawnDamageNumber(bullet.userData.damage, obstacles[j].mesh.position);
                            // Visual feedback for hit obstacle
                            obstacles[j].mesh.material.color.set(0xff0000); // Flash red
                            obstacles[j].lastHitTime = performance.now() / 1000;
                        } else {
                            console.log("Bullet hit unbreakable obstacle.");
                        }
                        disposeBulletMesh(bullet); // Return bullet to pool
                        playerBullets.splice(i, 1);
                        hitObstacle = true;
                        break;
                    }
                }
                if (hitObstacle) continue;

                // Remove if out of bounds
                if (bullet.position.length() > WORLD_BOUNDARY * 1.5) {
                    disposeBulletMesh(bullet); // Return bullet to pool
                    playerBullets.splice(i, 1);
                }
            }

            // Enemy bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.position.addScaledVector(bullet.userData.direction, bullet.userData.speed * delta);

                // Check collision with player
                if (playerMesh && bullet.position.distanceTo(playerMesh.position) < 2) {
                    if (!playerInvincible) {
                        playerHealth -= bullet.userData.damage;
                        updateUI();
                        flashDamage();
                        cameraShakeIntensity = 0.5;
                        cameraShakeTime = 0.1;
                        console.log(`Enemy bullet hit player. Player health: ${playerHealth}`);
                        if (playerHealth <= 0) {
                            gameOver();
                        }
                    } else {
                        console.log("Enemy bullet hit player, but shield is active!");
                    }
                    disposeBulletMesh(bullet); // Return bullet to pool
                    enemyBullets.splice(i, 1);
                    continue;
                }

                // Check collision with obstacles
                let hitObstacle = false;
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    // Skip if the obstacle is not visible or already destroyed
                    // Also check if obstacle has health Infinity (unbreakable)
                    if (!obstacles[j].mesh.visible || obstacles[j].health <= 0) continue;

                    const obstacleBox = getBoundingBox(obstacles[j].mesh);
                    const bulletSphere = new THREE.Sphere(bullet.position, bullet.geometry.parameters.radius);
                    if (obstacleBox.intersectsSphere(bulletSphere)) {
                         // Only damage if health is not Infinity (i.e., it's a breakable obstacle)
                         if (obstacles[j].health !== Infinity) { 
                            obstacles[j].health -= bullet.userData.damage; // Bullets damage obstacles
                            spawnDamageNumber(bullet.userData.damage, obstacles[j].mesh.position);
                            // Visual feedback for hit obstacle
                            obstacles[j].mesh.material.color.set(0xff0000); // Flash red
                            obstacles[j].lastHitTime = performance.now() / 1000;
                        } else {
                            console.log("Bullet hit unbreakable obstacle.");
                        }
                        disposeBulletMesh(bullet); // Return bullet to pool
                        enemyBullets.splice(i, 1);
                        hitObstacle = true;
                        break;
                    }
                }
                if (hitObstacle) continue;

                // Remove if out of bounds
                if (bullet.position.length() > WORLD_BOUNDARY * 1.5) {
                    disposeBulletMesh(bullet); // Return bullet to pool
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function updateEnemies(delta) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyMesh = enemy.mesh;

                // Update health bar position
                enemy.healthBarSprite.position.copy(enemyMesh.position);
                enemy.healthBarSprite.position.y += 4; // Position above enemy mesh

                // Enemy movement towards player
                if (playerMesh) {
                    let directionToPlayer = new THREE.Vector3().subVectors(playerMesh.position, enemyMesh.position).normalize();
                    let moveAmount = 5 * delta; // Enemy speed
                    let enemyMovementVector = directionToPlayer.clone().multiplyScalar(moveAmount);

                    // Obstacle avoidance logic
                    let avoidanceVector = new THREE.Vector3();
                    for (const obstacle of obstacles) {
                        if (!obstacle.mesh.visible || obstacle.health <= 0) continue;
                        const distance = enemyMesh.position.distanceTo(obstacle.mesh.position);
                        // Avoidance only if within a certain radius and not a boundary wall
                        if (distance < ENEMY_AVOIDANCE_RADIUS && !obstacle.mesh.userData.isBoundary) {
                            const repulsionDirection = new THREE.Vector3().subVectors(enemyMesh.position, obstacle.mesh.position).normalize();
                            // Apply stronger force closer to the obstacle
                            avoidanceVector.addScaledVector(repulsionDirection, (ENEMY_AVOIDANCE_RADIUS - distance) / ENEMY_AVOIDANCE_RADIUS * ENEMY_AVOIDANCE_FORCE);
                        }
                    }

                    // Combine movement and avoidance
                    enemyMovementVector.add(avoidanceVector.multiplyScalar(delta * 60)); // Scale avoidance force
                    enemyMovementVector.normalize().multiplyScalar(moveAmount);

                    const enemyCurrentPos = enemyMesh.position.clone();
                    const enemyNextPosX = enemyCurrentPos.x + enemyMovementVector.x;
                    const enemyNextPosZ = enemyCurrentPos.z + enemyMovementVector.z;

                    const enemyBox = getBoundingBox(enemyMesh);

                    // X-axis collision check for enemy
                    let collisionX = false;
                    if (enemyMovementVector.x !== 0) {
                        const potentialEnemyBoxX = enemyBox.clone();
                        potentialEnemyBoxX.translate(new THREE.Vector3(enemyMovementVector.x, 0, 0));

                        for (const obstacle of obstacles) {
                            if (!obstacle.mesh.visible || obstacle.health <= 0) continue;
                            const obstacleBox = getBoundingBox(obstacle.mesh);
                            if (potentialEnemyBoxX.intersectsBox(obstacleBox)) {
                                collisionX = true;
                                break;
                            }
                        }
                    }
                    if (!collisionX) {
                        enemyMesh.position.x = enemyNextPosX;
                    }

                    // Z-axis collision check for enemy
                    let collisionZ = false;
                    if (enemyMovementVector.z !== 0) {
                        const potentialEnemyBoxZ = enemyBox.clone();
                        potentialEnemyBoxZ.translate(new THREE.Vector3(0, 0, enemyMovementVector.z));

                        for (const obstacle of obstacles) {
                            if (!obstacle.mesh.visible || obstacle.health <= 0) continue;
                            const obstacleBox = getBoundingBox(obstacle.mesh);
                            if (potentialEnemyBoxZ.intersectsBox(obstacleBox)) {
                                collisionZ = true;
                                break;
                            }
                        }
                    }
                    if (!collisionZ) {
                        enemyMesh.position.z = enemyNextPosZ;
                    }

                    // Clamp enemy position to world boundaries
                    enemyMesh.position.x = Math.max(WORLD_MIN, Math.min(WORLD_BOUNDARY, enemyMesh.position.x));
                    enemyMesh.position.z = Math.max(WORLD_MIN, Math.min(WORLD_BOUNDARY, enemyMesh.position.z));
                }

                // Enemy rotation (added for visual flair)
                enemy.mesh.rotation.y += 0.5 * delta; // Rotate around its Y-axis

                // Enemy shooting
                if (playerMesh && performance.now() / 1000 - enemy.lastShotTime > ENEMY_SHOOT_INTERVAL && enemy.mesh.position.distanceTo(playerMesh.position) < 50) {
                    shootBullet(enemy.mesh.position, playerMesh.position, false);
                    enemy.lastShotTime = performance.now() / 1000;
                }

                if (enemy.health <= 0) {
                    spawnExplosion(enemy.mesh.position, Tone.now()); // Pass Tone.now()
                    let scoreEarned = enemy.mesh.userData.isBoss ? 500 : 100;
                    if (scoreMultiplierActive) {
                        scoreEarned *= 2;
                        console.log("Score multiplier active! Doubling score.");
                    }
                    playerScore += scoreEarned;
                    updateUI();
                    scene.remove(enemy.mesh);
                    scene.remove(enemy.healthBarSprite); // Remove health bar
                    enemies.splice(i, 1);
                    cameraShakeIntensity = 1.0;
                    cameraShakeTime = 0.2;
                    console.log(`Enemy defeated! Gained ${scoreEarned} points. Total score: ${playerScore}`);

                    enemiesRemainingInWave--;
                    // Only start the next wave if all *counted* enemies are gone AND no active enemy meshes exist
                    if (enemiesRemainingInWave <= 0 && enemies.length === 0) {
                        startNextWave();
                    } else { 
                        // If there are still enemies to spawn for this wave, spawn one to keep up density
                        const currentWaveConfig = WAVE_CONFIG[Math.min(currentWave - 1, WAVE_CONFIG.length - 1)];
                        if (enemies.length < currentWaveConfig.numEnemies) {
                            spawnRandomEnemy(currentWaveConfig.bossChance);
                        }
                    }
                }
            }

            // Dynamic enemy spawning (for ongoing waves)
            // This logic is for continuously spawning enemies if the number on screen is low,
            // independent of `enemiesRemainingInWave` for the initial wave spawn count.
            // It ensures the arena stays populated.
            enemySpawnTimer += delta;
            const currentWaveConfig = WAVE_CONFIG[Math.min(currentWave - 1, WAVE_CONFIG.length - 1)];
            if (enemySpawnTimer >= enemySpawnInterval && enemies.length < currentWaveConfig.numEnemies) {
                spawnRandomEnemy(currentWaveConfig.bossChance);
                enemySpawnTimer = 0;
            }
        }

        function updateObstacles(delta) {
            const currentTime = performance.now() / 1000;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                // Only process if health is not Infinity (i.e., not an unbreakable boundary wall or cuboid obstacle)
                if (obstacle.health <= 0 && obstacle.health !== Infinity) {
                    spawnExplosion(obstacle.mesh.position, Tone.now()); // Pass Tone.now()
                    scene.remove(obstacle.mesh); // Ensure mesh is removed
                    obstacles.splice(i, 1);
                    console.log("Obstacle destroyed!");
                } else if (obstacle.health !== Infinity && obstacle.lastHitTime > 0 && currentTime - obstacle.lastHitTime > 0.1) {
                    // Reset color after a brief flash
                    obstacle.mesh.material.color.set(new THREE.Color(obstacle.originalColor)); // Use new THREE.Color for reset
                    obstacle.lastHitTime = 0; // Reset last hit time
                }
            }
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const pu = powerUps[i];
                // Check if player is close enough to pick up the power-up
                if (playerMesh && pu.position.distanceTo(playerMesh.position) < POWERUP_PICKUP_RADIUS) { // Increased pickup radius
                    if (Tone.context && Tone.context.state === 'running') { // Check Tone.context exists and is running
                        powerupSound.triggerAttackRelease("E5", "16n");
                    }
                    console.log(`Collected ${pu.userData.type} power-up.`);
                    const currentTime = performance.now() / 1000;

                    const playerBodyMaterial = playerMesh.userData.bodyMaterial;
                    const playerTurretMaterial = playerMesh.userData.turretMaterial;

                    switch (pu.userData.type) {
                        case 'shield':
                            playerShieldMesh.visible = true;
                            playerInvincible = true;
                            setTimeout(() => {
                                playerShieldMesh.visible = false;
                                playerInvincible = false;
                                console.log("Shield deactivated.");
                            }, 5000);
                            showDramaMessage("Shield Activated!", 500 / 2); // Reduced duration
                            break;
                        case 'health':
                            playerHealth = Math.min(100, playerHealth + 25);
                            updateUI();
                            showDramaMessage("Health Restored!", 500 / 2); // Reduced duration
                            break;
                        case 'healthPack': // New: HP Pack
                            playerHealth = Math.min(100, playerHealth + 50); // Restore more health
                            updateUI();
                            showDramaMessage("HP Pack Collected! +50 Health!", 500 / 2); // Reduced duration
                            // Respawn health pack after a delay
                            setTimeout(() => spawnRandomPowerUp('healthPack'), HEALTH_PACK_RESPAWN_TIME * 1000);
                            break;
                        case 'nukePack': // New: Nuke Pack
                            console.log("Nuke Pack Collected! Detonating all enemies.");
                            showDramaMessage("NUKE! All Enemies Eliminated!", 2000 / 2); // Kept longer for impact
                            let explosionTimeOffset = 0; // Initialize offset for sequential explosions
                            enemies.forEach(enemy => {
                                // Schedule explosions with a small, increasing offset
                                spawnExplosion(enemy.mesh.position, Tone.now() + explosionTimeOffset);
                                explosionTimeOffset += 0.01; // Small increment for each explosion
                                let scoreEarned = enemy.mesh.userData.isBoss ? 500 : 100;
                                if (scoreMultiplierActive) {
                                    scoreEarned *= 2;
                                }
                                playerScore += scoreEarned;
                                scene.remove(enemy.mesh);
                                scene.remove(enemy.healthBarSprite); // Remove health bar
                                enemiesRemainingInWave--; // Decrement remaining enemies for wave progression
                            });
                            enemies = []; // Clear the enemies array AFTER processing them for explosions
                            updateUI();
                            // If all enemies are cleared, just start next wave (game is endless)
                            if (enemiesRemainingInWave <= 0) {
                                startNextWave();
                            }
                            break;
                        case 'scoreMultiplier':
                            scoreMultiplierActive = true;
                            scoreMultiplierEndTime = currentTime + SCORE_MULTIPLIER_DURATION;
                            showDramaMessage("Score Multiplier Active!", 500 / 2); // Reduced duration
                            break;
                        case 'damageBoost':
                            playerDamageMultiplier = 2; // Double damage
                            damageMultiplierEndTime = currentTime + DAMAGE_SPEED_BOOST_DURATION;
                            playerBodyMaterial.emissive.setHex(0xFFA500); // Orange glow
                            playerTurretMaterial.emissive.setHex(0xFFA500);
                            showDramaMessage("Damage Boost Active!", 500 / 2); // Reduced duration
                            break;
                        case 'speedBoost':
                            playerSpeedMultiplier = 2; // Double speed
                            speedMultiplierEndTime = currentTime + DAMAGE_SPEED_BOOST_DURATION;
                            playerBodyMaterial.emissive.setHex(0xFFFF00); // Yellow glow
                            playerTurretMaterial.emissive.setHex(0xFFFF00);
                            showDramaMessage("Speed Boost Active!", 500 / 2); // Reduced duration
                            break;
                    }
                    scene.remove(pu);
                    powerUps.splice(i, 1);
                }
            }
        }

        function spawnExplosion(position, playTime = Tone.now()) { // Add playTime parameter with default
            const numParticles = 30; // More particles
            const particleGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const baseColor = new THREE.Color(0xffa500); // Orange base color

            for (let i = 0; i < numParticles; i++) {
                // Vary particle color slightly
                const color = baseColor.clone().multiplyScalar(Math.random() * 0.5 + 0.5); // Randomize brightness
                const particleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                const speed = Math.random() * 7 + 3; // Faster, more varied speed
                const angleX = Math.random() * Math.PI * 2;
                const angleY = Math.random() * Math.PI * 2;
                particle.userData.direction = new THREE.Vector3(
                    Math.cos(angleX) * Math.sin(angleY),
                    Math.cos(angleY),
                    Math.sin(angleX) * Math.sin(angleY)
                ).normalize();
                particle.userData.speed = speed;
                particle.userData.lifetime = 1.0;
                particle.scale.setScalar(Math.random() * 1.5 + 0.5); // Vary particle size
                explosionParticles.push(particle);
                scene.add(particle);
            }
            if (Tone.context && Tone.context.state === 'running') { // Check Tone.context exists and is running
                explosionSound.triggerAttackRelease("8n", playTime); // Use the provided playTime
            }
        }

        function updateExplosionParticles(delta) {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                particle.position.addScaledVector(particle.userData.direction, particle.userData.speed * delta);
                particle.userData.lifetime -= delta;
                particle.material.opacity = Math.max(0, particle.userData.lifetime);

                if (particle.userData.lifetime <= 0) {
                    scene.remove(particle);
                    explosionParticles.splice(i, 1);
                }
            }
        }

        function spawnDamageNumber(damage, position, color = 0xff0000) { // Added color parameter
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = "bold 32px Arial";
            ctx.fillStyle = new THREE.Color(color).getStyle(); // Use Three.js Color for consistency
            ctx.textAlign = "center";
            ctx.fillText(damage.toFixed(0), 64, 40); // Round damage for display
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
            sprite.position.copy(position);
            sprite.scale.set(10, 5, 1);
            damageNumbers.push({ sprite: sprite, lifetime: 1.0 });
            scene.add(sprite);
        }

        function updateDamageNumbers(delta) {
            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const dmgObj = damageNumbers[i];
                dmgObj.lifetime -= delta;
                dmgObj.sprite.material.opacity = Math.max(dmgObj.lifetime, 0);
                dmgObj.sprite.position.y += delta * 5;
                if (dmgObj.lifetime <= 0) {
                    scene.remove(dmgObj.sprite);
                    damageNumbers.splice(i, 1);
                }
            }
        }

        function flashDamage() {
            damageFlash.style.opacity = 0.6;
            setTimeout(() => damageFlash.style.opacity = 0, 100);
            console.log("Player took damage!");
        }

        function showDramaMessage(message, duration = 3000) {
            dramaOverlay.innerHTML = message; // Use innerHTML to allow <br>
            dramaOverlay.style.opacity = 1;
            if (duration > 0) { // Only set timeout if duration is positive
                setTimeout(() => {
                    dramaOverlay.style.opacity = 0;
                }, duration);
            }
        }

        /**
         * Creates a dynamic particle background for the scene.
         */
        function createParticleBackground() {
            const particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();

            // Spawn particles in a much larger area beyond the game world
            // Ensure particles are well outside the WORLD_BOUNDARY
            const worldSize = WORLD_BOUNDARY - WORLD_MIN; // 200 units
            const buffer = worldSize * 2; // Increased buffer for more distant feel
            const minCoord = WORLD_MIN - buffer;
            const maxCoord = WORLD_BOUNDARY + buffer;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = Math.random() * (maxCoord - minCoord) + minCoord;
                const y = Math.random() * 300 - 150; // More vertical spread
                const z = Math.random() * (maxCoord - minCoord) + minCoord;
                positions.push(x, y, z);

                // Assign a subtle color, e.g., dark blue/purple, more varied
                color.setHSL(Math.random() * 0.2 + 0.55, 0.6, Math.random() * 0.4 + 0.1); // Blue-ish to purplish hues, wider brightness
                colors.push(color.r, color.g, color.b);
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 2.5, // Slightly larger particles
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            backgroundParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(backgroundParticles);
            console.log(`Created ${PARTICLE_COUNT} background particles.`);
        }

        /**
         * Updates the position of the background particles to create a subtle movement effect.
         * @param {number} delta - Time elapsed since last frame.
         */
        function updateParticleBackground(delta) {
            if (backgroundParticles) {
                const positions = backgroundParticles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    // Move particles slowly towards the camera (negative Z)
                    positions[i + 2] += PARTICLE_SPEED * delta;

                    // If a particle moves past the camera's front view, reset it to the far end
                    // Ensure it resets far enough back to avoid popping into view
                    if (positions[i + 2] > camera.position.z + 100) { // If it passes a certain point in front of camera (increased distance)
                        positions[i + 2] = camera.position.z - 500; // Reset far behind camera (increased distance)
                    }
                }
                backgroundParticles.geometry.attributes.position.needsUpdate = true;
            }
        }

        /**
         * Updates the visual state of the special attack button's cooldown overlay.
         */
        function updateSpecialAttackUI() {
            const currentTime = performance.now() / 1000;
            const timeSinceLastSpecial = currentTime - lastSpecialAttackTime;

            if (timeSinceLastSpecial < SPECIAL_ATTACK_COOLDOWN) {
                const remainingTime = SPECIAL_ATTACK_COOLDOWN - timeSinceLastSpecial;
                specialAttackCooldownOverlay.textContent = Math.ceil(remainingTime);
                specialAttackCooldownOverlay.classList.add('visible');
                // You could also animate a circular fill here if desired
            } else {
                specialAttackCooldownOverlay.classList.remove('visible');
                specialAttackCooldownOverlay.textContent = ''; // Clear text
            }
        }

        /**
         * Draws the mini-map.
         */
        function drawMiniMap() {
            if (!miniMapCtx || !playerMesh) return;

            const mapWidth = miniMapCanvas.width;
            const mapHeight = miniMapCanvas.height;
            const mapCenterX = mapWidth / 2;
            const mapCenterY = mapHeight / 2;
            const mapScale = Math.min(mapWidth, mapHeight) / WORLD_SIZE; // Scale world units to map pixels

            miniMapCtx.clearRect(0, 0, mapWidth, mapHeight);
            miniMapCtx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Transparent dark background
            miniMapCtx.fillRect(0, 0, mapWidth, mapHeight);

            // Convert world coordinates to mini-map coordinates
            const worldToMapX = (worldX) => (worldX - WORLD_MIN) * mapScale;
            const worldToMapZ = (worldZ) => (worldZ - WORLD_MIN) * mapScale; // Z in world is Y in map

            // Draw boundaries
            miniMapCtx.strokeStyle = '#00ff00';
            miniMapCtx.lineWidth = 2;
            miniMapCtx.strokeRect(worldToMapX(WORLD_MIN), worldToMapZ(WORLD_MIN), worldToMapX(WORLD_BOUNDARY) - worldToMapX(WORLD_MIN), worldToMapZ(WORLD_BOUNDARY) - worldToMapZ(WORLD_MIN));

            // Draw player
            miniMapCtx.fillStyle = 'blue';
            miniMapCtx.beginPath();
            miniMapCtx.arc(worldToMapX(playerMesh.position.x), worldToMapZ(playerMesh.position.z), 3, 0, Math.PI * 2);
            miniMapCtx.fill();

            // Draw enemies
            miniMapCtx.fillStyle = 'red';
            enemies.forEach(enemy => {
                miniMapCtx.beginPath();
                miniMapCtx.rect(worldToMapX(enemy.mesh.position.x) - 2, worldToMapZ(enemy.mesh.position.z) - 2, 4, 4); // Square for enemy
                miniMapCtx.fill();
            });

            // Draw obstacles
            miniMapCtx.fillStyle = '#666666';
            obstacles.forEach(obstacle => {
                if (!obstacle.mesh.userData.isBoundary && obstacle.health > 0) { // Only draw non-boundary, alive obstacles
                    const bbox = getBoundingBox(obstacle.mesh);
                    const minX = worldToMapX(bbox.min.x);
                    const minZ = worldToMapZ(bbox.min.z);
                    const width = worldToMapX(bbox.max.x) - minX;
                    const depth = worldToMapZ(bbox.max.z) - minZ;
                    miniMapCtx.fillRect(minX, minZ, width, depth);
                }
            });

            // Draw power-ups
            powerUps.forEach(powerUp => {
                let color;
                switch (powerUp.userData.type) {
                    case 'health':
                    case 'healthPack': color = 'lime'; break;
                    case 'shield': color = 'cyan'; break;
                    case 'damageBoost': color = 'orange'; break;
                    case 'speedBoost': color = 'yellow'; break;
                    case 'scoreMultiplier': color = 'purple'; break;
                    case 'nukePack': color = 'magenta'; break;
                    default: color = 'white';
                }
                miniMapCtx.fillStyle = color;
                miniMapCtx.beginPath();
                miniMapCtx.arc(worldToMapX(powerUp.position.x), worldToMapZ(powerUp.position.z), 2, 0, Math.PI * 2);
                miniMapCtx.fill();
            });

            // Draw zones
            if (hazardZoneMesh) {
                miniMapCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                miniMapCtx.beginPath();
                miniMapCtx.arc(worldToMapX(hazardZoneCenter.x), worldToMapZ(hazardZoneCenter.z), hazardZoneRadius * mapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            }
            if (greenZoneMesh) {
                miniMapCtx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                miniMapCtx.beginPath();
                miniMapCtx.arc(worldToMapX(greenZoneMesh.position.x), worldToMapZ(greenZoneMesh.position.z), greenZoneMesh.radius * mapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            }
            if (blueZoneMesh) {
                miniMapCtx.fillStyle = 'rgba(0, 0, 255, 0.2)';
                miniMapCtx.beginPath();
                miniMapCtx.arc(worldToMapX(blueZoneMesh.position.x), worldToMapZ(blueZoneMesh.position.z), blueZoneMesh.radius * mapScale, 0, Math.PI * 2);
                miniMapCtx.fill();
            }
        }


        // --- Main Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (isGamePaused) {
                renderer.render(scene, camera); // Still render the paused scene
                return; // Stop game logic updates
            }

            const delta = clock.getDelta();

            // Only render the game if it's active, otherwise render the scene (for home screen)
            if (isGameActive) {
                updatePlayer(delta);
                updateBullets(delta);
                updateEnemies(delta);
                updateObstacles(delta); // Pass delta to updateObstacles for hit feedback
                updatePowerUps();
                updateExplosionParticles(delta);
                updateDamageNumbers(delta);
                updateSpecialAttackUI(); // Update the special attack button UI
                drawMiniMap(); // Draw mini-map

                // Camera shake effect
                if (cameraShakeTime > 0) {
                    camera.position.x += (Math.random() - 0.5) * cameraShakeIntensity;
                    camera.position.y += (Math.random() - 0.5) * cameraShakeIntensity;
                    cameraShakeTime -= delta;
                } else {
                    // Smoothly interpolate camera position and lookAt towards player
                    const cameraOffset = new THREE.Vector3(0, 30, 40);
                    const targetCameraPosition = playerMesh.position.clone().add(cameraOffset);
                    camera.position.lerp(targetCameraPosition, 0.1);
                    camera.lookAt(playerMesh.position);
                }
            }
            updateParticleBackground(delta); // Update particles even if game is not active
            renderer.render(scene, camera);
        }

        window.onload = preloadAssets;
    </script>
</body>
</html>
